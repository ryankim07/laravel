{
  "name": "expect",
  "version": "1.12.1",
  "description": "Write better assertions",
  "main": "lib/index",
  "dependencies": {
    "deep-equal": "^1.0.1",
    "is-regexp": "^1.0.0",
    "object-inspect": "^1.0.2"
  },
  "devDependencies": {
    "babel": "^5.4.7",
    "babel-core": "^5.4.7",
    "babel-eslint": "^4.1.1",
    "babel-loader": "^5.0.0",
    "eslint": "^1.3.1",
    "gzip-size": "^3.0.0",
    "karma": "^0.13.3",
    "karma-chrome-launcher": "^0.2.0",
    "karma-mocha": "^0.2.0",
    "karma-sourcemap-loader": "^0.3.5",
    "karma-webpack": "^1.7.0",
    "mocha": "^2.0.1",
    "pretty-bytes": "^2.0.1",
    "webpack": "^1.4.13"
  },
  "scripts": {
    "build": "babel ./modules -d lib --stage 0 --loose all --ignore '__tests__'",
    "build-umd": "NODE_ENV=production webpack modules/index.js umd/expect.js",
    "build-min": "NODE_ENV=production webpack -p modules/index.js umd/expect.min.js",
    "lint": "eslint modules",
    "test": "npm run lint && mocha --compilers js:babel/register --reporter spec 'modules/**/__tests__/*-test.js'",
    "test-browser": "npm run lint && karma start",
    "postinstall": "node npm-scripts/postinstall.js"
  },
  "keywords": [
    "expect",
    "assert",
    "test",
    "spec"
  ],
  "author": {
    "name": "Michael Jackson"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/mjackson/expect.git"
  },
  "bugs": {
    "url": "https://github.com/mjackson/expect/issues"
  },
  "homepage": "https://github.com/mjackson/expect",
  "readme": "# expect\n\n[![build status](https://img.shields.io/travis/mjackson/expect/master.svg?style=flat-square)](https://travis-ci.org/mjackson/expect)\n[![npm package](https://img.shields.io/npm/v/expect.svg?style=flat-square)](https://www.npmjs.org/package/expect)\n\n[expect](https://github.com/mjackson/expect) lets you write better assertions.\n\nWhen you use expect, you write assertions similarly to how you would say them, e.g. \"I expect this value to be equal to 3\" or \"I expect this array to contain 3\". When you write assertions in this way, you don't need to remember the order of actual and expected arguments to functions like `assert.equal`, which helps you write better tests.\n\n## Installation\n\nUsing [npm](https://www.npmjs.org/):\n\n    $ npm install expect\n\nThen with a module bundler like [webpack](https://webpack.github.io/), use as you would anything else:\n\n```js\n// using an ES6 transpiler, like babel\nimport expect, { createSpy, spyOn, isSpy } from 'expect'\n\n// not using an ES6 transpiler\nvar expect = require('expect')\nvar createSpy = expect.createSpy\nvar spyOn = expect.spyOn\nvar isSpy = expect.isSpy\n```\n\nThere is a UMD build in the npm package in the `umd` directory. Use it like:\n\n```js\nvar expect = require('expect/umd/expect.min')\n```\n\n## Assertions\n\n### toExist\n\n> `expect(object).toExist([message])`\n\nAsserts the given `object` is truthy.\n\n```js\nexpect('something truthy').toExist()\n```\n\n#### toNotExist\n\n> `expect(object).toNotExist([message])`\n\nAsserts the given `object` is falsy.\n\n```js\nexpect(null).toNotExist()\n```\n\n### toBe\n\n> `expect(object).toBe(value, [message])`\n\nAsserts that `object` is strictly equal to `value` using `===`.\n\n### toNotBe\n\n> `expect(object).toNotBe(value, [message])`\n\nAsserts that `object` is not strictly equal to `value` using `===`.\n\n### toEqual\n\n> `expect(object).toEqual(value, [message])`\n\nAsserts that the given `object` equals `value` using [deep-equal](https://www.npmjs.com/package/deep-equal).\n\n### toNotEqual\n\n> `expect(object).toNotEqual(value, [message])`\n\nAsserts that the given `object` is not equal to `value` using [deep-equal](https://www.npmjs.com/package/deep-equal).\n\n### toThrow\n\n> `expect(block).toThrow([error], [message])`\n\nAsserts that the given `block` `throw`s an error. The `error` argument may be a constructor (to test using `instanceof`), or a string/`RegExp` to test against `error.message`.\n\n```js\nexpect(function () {\n  throw new Error('boom!')\n}).toThrow(/boom/)\n```\n\n### withArgs\n\n> `expect(block).withArgs(...args).toThrow([error], [message])`\n\nAsserts that the given `block` `throw`s an error when called with `args`. The `error` argument may be a constructor (to test using `instanceof`), or a string/`RegExp` to test against `error.message`.\n\n```js\nexpect(function (check) {\n  if (check === 'bad')\n    throw new Error('boom!')\n}).withArgs('bad').toThrow(/boom/)\n```\n\n### withContext\n\n> `expect(block).withContext(context).toThrow([error], [message])`\n\nAsserts that the given `block` `throw`s an error when called in the given `context`. The `error` argument may be a constructor (to test using `instanceof`), or a string/`RegExp` to test against `error.message`.\n\n```js\nexpect(function () {\n  if (this.check === 'bad')\n    throw new Error('boom!')\n}).withContext({ check: 'bad' }).toThrow(/boom/)\n```\n\n### toNotThrow\n\n> `expect(block).toNotThrow([message])`\n\nAsserts that the given `block` does not `throw`.\n\n### toBeA(constructor)\n\n> `expect(object).toBeA(constructor, [message])`<br>\n> `expect(object).toBeAn(constructor, [message])`\n\nAsserts the given `object` is an `instanceof constructor`.\n\n```js\nexpect(new User).toBeA(User)\nexpect(new Asset).toBeAn(Asset)\n```\n\n### toBeA(string)\n\n> `expect(object).toBeA(string, [message])`<br>\n> `expect(object).toBeAn(string, [message])`\n\nAsserts the `typeof` the given `object` is `string`.\n\n```js\nexpect(2).toBeA('number')\n```\n\n### toNotBeA(constructor)\n\n> `expect(object).toNotBeA(constructor, [message])`<br>\n> `expect(object).toNotBeAn(constructor, [message])`\n\nAsserts the given `object` is *not* an `instanceof constructor`.\n\n```js\nexpect(new User).toBeA(User)\nexpect(new Asset).toBeAn(Asset)\n```\n\n### toNotBeA(string)\n\n> `expect(object).toNotBeA(string, [message])`<br>\n> `expect(object).toNotBeAn(string, [message])`\n\nAsserts the `typeof` the given `object` is *not* `string`.\n\n```js\nexpect(2).toBeA('number')\n```\n\n### toMatch\n\n> `expect(string).toMatch(pattern, [message])`\n\nAsserts the given `string` matches `pattern`, which must be a `RegExp`.\n\n```js\nexpect('a string').toMatch(/string/)\n```\n\n### toBeLessThan\n\n> `expect(number).toBeLessThan(value, [message])`<br>\n> `expect(number).toBeFewerThan(value, [message])`\n\nAsserts the given `number` is less than `value`.\n\n```js\nexpect(2).toBeLessThan(3)\n```\n\n### toBeGreaterThan\n\n> `expect(number).toBeGreaterThan(value, [message])`<br>\n> `expect(number).toBeMoreThan(value, [message])`\n\nAsserts the given `number` is greater than `value`.\n\n```js\nexpect(3).toBeGreaterThan(2)\n```\n\n### toInclude\n\n> `expect(array).toInclude(value, [comparator], [message])`<br>\n> `expect(array).toContain(value, [comparator], [message])`\n\nAsserts the given `array` contains `value`. The `comparator` function, if given, should compare two objects and either `return false` or `throw` if they are not equal. It defaults to `assert.deepEqual`.\n\n```js\nexpect([ 1, 2, 3 ]).toInclude(3)\n```\n\n### toExclude\n\n> `expect(array).toExclude(value, [comparator], [message])`<br>\n> `expect(array).toNotContain(value, [comparator], [message])`\n\nAsserts the given `array` does not contain `value`. The `comparator` function, if given, should compare two objects and either `return false` or `throw` if they are not equal. It defaults to `assert.deepEqual`.\n\n```js\nexpect([ 1, 2, 3 ]).toExclude(4)\n```\n\n### (string) toInclude\n\n> `expect(string).toInclude(value, [message])`<br>\n> `expect(string).toContain(value, [message])`\n\nAsserts the given `string` contains `value`.\n\n```js\nexpect('hello world').toInclude('world')\nexpect('hello world').toContain('world')\n```\n\n### (string) toExclude\n\n> `expect(string).toExclude(value, [message])`<br>\n> `expect(string).toNotContain(value, [message])`\n\nAsserts the given `string` does not contain `value`.\n\n```js\nexpect('hello world').toExclude('goodbye')\nexpect('hello world').toNotContain('goodbye')\n```\n\n## Chaining Assertions\n\nEvery assertion returns an `Expectation` object, so you can chain assertions together.\n\n```js\nexpect(3.14)\n  .toExist()\n  .toBeLessThan(4)\n  .toBeGreaterThan(3)\n```\n\n## Spies\n\nexpect also includes the ability to create spy functions that can track the calls that are made to other functions and make various assertions based on the arguments and context that were used.\n\n```js\nvar video = {\n  play: function () {},\n  pause: function () {},\n  rewind: function () {}\n}\n\nvar spy = expect.spyOn(video, 'play')\n\nvideo.play('some', 'args')\n\nexpect(spy.calls.length).toEqual(1)\nexpect(spy.calls[0].context).toBe(video)\nexpect(spy.calls[0].arguments).toEqual([ 'some', 'args' ])\nexpect(spy).toHaveBeenCalled()\nexpect(spy).toHaveBeenCalledWith('some', 'args')\n\nspy.restore()\nexpect.restoreSpies()\n```\n\n### createSpy\n\n> `expect.createSpy()`\n\nCreates a spy function.\n\n```js\nvar spy = expect.createSpy()\n```\n\n### spyOn\n\n> `expect.spyOn(target, method)`\n\nReplaces the `method` in `target` with a spy.\n\n```js\nvar video = {\n  play: function () {}\n}\n\nexpect.spyOn(video, 'play')\nvideo.play()\n\nspy.restore()\n```\n\n### restoreSpies\n\n> `expect.restoreSpies()`\n\nRestores all spies created with `expect.spyOn()`. This is the same as calling `spy.restore()` on all spies created.\n\n```js\n// mocha.js example\nbeforeEach(function () {\n  expect.spyOn(profile, 'load')\n})\n\nafterEach(function () {\n  expect.restoreSpies()\n})\n\nit('works', function () {\n  profile.load()\n  expect(profile.load).toHaveBeenCalled()\n})\n```\n\n## Spy methods\n\n### andCall\n\n> `spy.andCall(fn)`\n\nMakes the spy invoke a function `fn` when called.\n\n```\nvar dice = createSpy().andCall(function () {\n  return (Math.random() * 6) | 0\n})\n```\n\n### andCallThrough\n\n> `spy.andCallThrough()`\n\nMakes the spy call the original function it's spying on.\n\n```js\nspyOn(profile, 'load').andCallThrough()\n\nvar getEmail = createSpy(function () {\n  return \"hi@gmail.com\"\n}).andCallThrough()\n```\n\n### andReturn\n\n> `spy.andReturn(object)`\n\nMakes the spy return a value.\n\n```js\nvar dice = expect.createSpy().andReturn(3)\n```\n\n### andThrow\n\n> `spy.andThrow(error)`\n\nMakes the spy throw an `error` when called.\n\n```js\nvar failing = expect.createSpy()\n  .andThrow(new Error('Not working'))\n```\n\n### restore\n\n> `spy.restore()`\n\nRestores a spy originally created with `expect.spyOn()`.\n\n## Extending expect\n\nYou can add your own assertions using `expect.extend` and `expect.assert`:\n\n```js\nexpect.extend({\n  toBeAColor() {\n    expect.assert(\n      this.actual.match(/^#[a-fA-F0-9]{6}$/),\n      'expected %s to be an HTML color',\n      this.actual\n    )\n  }\n})\n\nexpect('#ff00ff').toBeAColor()\n```\n\n## Issues\n\nPlease file issues on the [issue tracker on GitHub](https://github.com/mjackson/expect/issues).\n\n## Tests\n\nTo run the tests in node:\n\n    $ npm install\n    $ npm test\n\nTo run the tests in Chrome:\n\n    $ npm install\n    $ npm run test-browser\n",
  "readmeFilename": "README.md",
  "_id": "expect@1.12.1",
  "dist": {
    "shasum": "ab1cb56d453b81cb04527e801c3603628d8e0455"
  },
  "_from": "expect@^1.6.0",
  "_resolved": "https://registry.npmjs.org/expect/-/expect-1.12.1.tgz"
}
